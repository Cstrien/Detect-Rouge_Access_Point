import logging
import requests
from requests.auth import HTTPBasicAuth
from telegram import Update, InputFile, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfbase import pdfmetrics
import os
import time
from datetime import datetime, timedelta

TOKEN = "8074321892:AAF6glPFFhVkWdS_FWVBYaMN4MkE8jsEjmY"

KISMET_URL = "http://localhost:2501"
KISMET_USERNAME = "kali" 
KISMET_PASSWORD = "kali" 


FONT_PATH = "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
FONT_NAME = "DejaVu"

logging.basicConfig(
    filename="bot.log",
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

ssid_history = {}



def register_font():
    """ƒêƒÉng k√Ω font ch·ªØ n·∫øu t·ªìn t·∫°i."""
    if os.path.exists(FONT_PATH):
        try:
            pdfmetrics.registerFont(TTFont(FONT_NAME, FONT_PATH))
            logger.info(f"ƒê√£ ƒëƒÉng k√Ω font th√†nh c√¥ng: {FONT_PATH}")
            return True
        except Exception as e:
            logger.error(f"L·ªói ƒëƒÉng k√Ω font {FONT_PATH}: {e}")
            return False
    else:
        logger.warning(f"Kh√¥ng t√¨m th·∫•y file font t·∫°i: {FONT_PATH}. Ch·ª©c nƒÉng PDF c√≥ th·ªÉ b·ªã ·∫£nh h∆∞·ªüng.")
        return False


FONT_REGISTERED = register_font()

# üì° H√†m l·∫•y d·ªØ li·ªáu t·ª´ Kismet API
def fetch_kismet_data(endpoint):
    try:
        url = f"{KISMET_URL}{endpoint}"
        response = requests.get(url, auth=HTTPBasicAuth(KISMET_USERNAME, KISMET_PASSWORD), timeout=15) 
        response.raise_for_status() #

        content_type = response.headers.get("Content-Type", "")
        if "application/json" not in content_type:
            logger.error(f"Kismet endpoint {endpoint} kh√¥ng tr·∫£ v·ªÅ JSON. Content-Type: {content_type}")
            return None, f"‚ùå D·ªØ li·ªáu tr·∫£ v·ªÅ t·ª´ Kismet kh√¥ng h·ª£p l·ªá (kh√¥ng ph·∫£i JSON) cho endpoint: {endpoint}"

        return response.json(), None

    except requests.exceptions.ConnectionError as e:
        logger.error(f"L·ªói k·∫øt n·ªëi Kismet: {e}")
        return None, f"‚ùå L·ªói k·∫øt n·ªëi Kismet: Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi {KISMET_URL}. Vui l√≤ng ki·ªÉm tra Kismet c√≥ ƒëang ch·∫°y v√† URL/port ƒë√∫ng kh√¥ng."
    except requests.exceptions.Timeout:
        logger.error(f"L·ªói Kismet Timeout cho endpoint: {endpoint}")
        return None, f"‚ùå L·ªói Kismet Timeout: Y√™u c·∫ßu t·ªõi {endpoint} m·∫•t qu√° nhi·ªÅu th·ªùi gian."
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 401:
            logger.error("L·ªói x√°c th·ª±c Kismet (401).")
            return None, "‚ùå L·ªói x√°c th·ª±c Kismet (401): Vui l√≤ng ki·ªÉm tra Username/Password."
        logger.error(f"L·ªói HTTP t·ª´ Kismet ({e.response.status_code}): {e}")
        return None, f"‚ùå L·ªói HTTP t·ª´ Kismet ({e.response.status_code}) cho endpoint: {endpoint}."
    except requests.exceptions.RequestException as e:
        logger.error(f"L·ªói y√™u c·∫ßu Kismet kh√¥ng x√°c ƒë·ªãnh: {e}")
        return None, f"‚ùå L·ªói y√™u c·∫ßu Kismet kh√¥ng x√°c ƒë·ªãnh: {e}"
    except ValueError as e: # L·ªói khi parse JSON
        logger.error(f"L·ªói parse JSON t·ª´ Kismet endpoint {endpoint}: {e}")
        return None, f"‚ùå D·ªØ li·ªáu tr·∫£ v·ªÅ t·ª´ Kismet kh√¥ng h·ª£p l·ªá (l·ªói parse JSON) cho endpoint: {endpoint}"

# Chia nh·ªè tin nh·∫Øn n·∫øu v∆∞·ª£t qu√° gi·ªõi h·∫°n Telegram (4096 k√Ω t·ª±)
def split_message(text, chunk_size=4000):
    if not isinstance(text, str): 
       text = str(text)
    for i in range(0, len(text), chunk_size):
        yield text[i:i + chunk_size]


async def get_all_ap():
    """L·∫•y danh s√°ch APs v√† ƒë·ªãnh d·∫°ng ch√∫ng th√†nh list c√°c string."""
    data, error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if error:
        return [error]

    if not data or not isinstance(data, list):
         logger.warning("D·ªØ li·ªáu APs tr·∫£ v·ªÅ kh√¥ng ph·∫£i list ho·∫∑c r·ªóng.")
         return ["‚ÑπÔ∏è Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu AP h·ª£p l·ªá t·ª´ Kismet ho·∫∑c kh√¥ng c√≥ AP n√†o."]

    ap_list = []
    for ap in data:
        if ap.get("kismet.device.base.type") == "Wi-Fi AP":
            ssid = ap.get("kismet.device.base.commonname", "·∫®n/Kh√¥ng t√™n")
            bssid = ap.get("kismet.device.base.macaddr", "Unknown BSSID")
            encryption=ap.get("kismet.device.base.crypt","Unknown_Encryption")
           
            signal_info = ap.get("kismet.common.signal", {})
            signal_dbm = signal_info.get("last_signal_dbm", "N/A")
            channel = ap.get("kismet.phy.dot11.channel", "N/A") # L·∫•y k√™nh

            ap_list.append(
                f"üì° **SSID:** `{ssid}`\n"
                f"üîç **BSSID:** `{bssid.upper()}`\n"
                f"üîí **B·∫£o m·∫≠t:** `{encryption}`\n"
                f"üì∂ **K√™nh:** `{channel}` | **T√≠n hi·ªáu:** `{signal_dbm} dBm`\n" 
                f"„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è"
            )

    return ap_list if ap_list else ["‚úÖ Kh√¥ng t√¨m th·∫•y AP n√†o!"]

async def get_ap_monitor_data():
    """L·∫•y d·ªØ li·ªáu SSID v√† BSSID c·∫ßn thi·∫øt cho vi·ªác gi√°m s√°t."""
    data, error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if error:
        return None, error

    if not data or not isinstance(data, list):
         logger.warning("D·ªØ li·ªáu APs monitor tr·∫£ v·ªÅ kh√¥ng ph·∫£i list ho·∫∑c r·ªóng.")
         return [], None 

    ap_pairs = []
    for ap in data:
        if ap.get("kismet.device.base.type") == "Wi-Fi AP":
            ssid = ap.get("kismet.device.base.commonname", "Unknown_SSID")
            bssid = ap.get("kismet.device.base.macaddr")
            if bssid: 
               ap_pairs.append({"ssid": ssid, "bssid": bssid.lower()}) 

    return ap_pairs, None

async def monitor_ssid_changes():
    """Gi√°m s√°t s·ª± thay ƒë·ªïi SSID c·ªßa c√°c AP ƒë√£ bi·∫øt BSSID."""
    global ssid_history
    ap_pairs, error = await get_ap_monitor_data()

    if error:
        return [error] # Tr·∫£ v·ªÅ l·ªói

    if ap_pairs is None: 
        return ["‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu AP ƒë·ªÉ gi√°m s√°t."]

    rogue_aps = []

    current_bssid_map = {ap['bssid']: ap['ssid'] for ap in ap_pairs}

    for bssid, current_ssid in current_bssid_map.items():
        if bssid not in ssid_history:
            # BSSID m·ªõi, ghi nh·∫≠n l·∫ßn ƒë·∫ßu
            ssid_history[bssid] = {current_ssid}
        elif current_ssid not in ssid_history[bssid]:
            # BSSID ƒë√£ bi·∫øt nh∆∞ng c√≥ SSID m·ªõi
            old_ssids = ssid_history[bssid]
            ssid_history[bssid].add(current_ssid) # Th√™m SSID m·ªõi v√†o l·ªãch s·ª≠
            rogue_aps.append(f"üö® **RAP Detected (SSID Change):**\n"
                             f"   BSSID: `{bssid.upper()}`\n"
                             f"   SSID M·ªõi: `{current_ssid}`\n"
                             f"   SSIDs Tr∆∞·ªõc ƒë√≥: `{', '.join(old_ssids)}`")
            logger.warning(f"RAP Ph√°t hi·ªán (SSID Change): BSSID: {bssid}, SSID m·ªõi: {current_ssid}, SSIDs c≈©: {old_ssids}")
    return rogue_aps if rogue_aps else [] 

async def get_alerts(limit=5):
    """L·∫•y danh s√°ch c·∫£nh b√°o t·ª´ Kismet (gi·ªõi h·∫°n s·ªë l∆∞·ª£ng)."""
    data, error = fetch_kismet_data("/alerts/all_alerts.json")
    if error:
        return [error]

    if not data or not isinstance(data, list):
        return ["‚úÖ Kh√¥ng c√≥ c·∫£nh b√°o n√†o t·ª´ Kismet ho·∫∑c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá!"]
    try:
        sorted_alerts = sorted(data, key=lambda x: x.get('kismet.alert.timestamp', 0) or x.get('kismet.alert.sec', 0), reverse=True)
    except Exception as e:
        logger.warning(f"Kh√¥ng th·ªÉ s·∫Øp x·∫øp c·∫£nh b√°o theo timestamp: {e}. S·ª≠ d·ª•ng th·ª© t·ª± g·ªëc.")
        sorted_alerts = data

    latest_alerts = sorted_alerts[:limit] 
    alert_list = []
    for alert in latest_alerts:
        header = alert.get("kismet.alert.header", "N/A")
        text = alert.get("kismet.alert.text", "Kh√¥ng c√≥ m√¥ t·∫£")

        # L·∫•y timestamp v√† ƒë·ªãnh d·∫°ng
        timestamp_sec = alert.get('kismet.alert.timestamp') or alert.get('kismet.alert.sec', 0)
        if timestamp_sec:
            try:
                dt_object = datetime.fromtimestamp(timestamp_sec)
                timestamp_str = dt_object.strftime("%Y-%m-%d %H:%M:%S")
            except Exception:
                timestamp_str = str(timestamp_sec) 
        else:
            timestamp_str = "N/A"

        alert_list.append(f"üîî **{header}**\n"
                          f"   üìå {text}\n"
                          f"   üïí {timestamp_str}\n"
                          f"{'-'*30}")

    return alert_list if alert_list else ["‚úÖ Kh√¥ng c√≥ c·∫£nh b√°o n√†o trong gi·ªõi h·∫°n y√™u c·∫ßu."]


async def get_clients_by_ap(ssid_filter):
    logger.info(f"B·∫Øt ƒë·∫ßu t√¨m client cho SSID: {ssid_filter}")
    target_bssid = None
    aps_data, aps_error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if aps_error:
        return [f"‚ùå L·ªói khi t√¨m BSSID cho SSID '{ssid_filter}': {aps_error}"]
    if not aps_data or not isinstance(aps_data, list):
        return [f"‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y AP n√†o c√≥ SSID kh·ªõp '{ssid_filter}'."]

    found_aps = []
    for ap in aps_data:
        if ap.get("kismet.device.base.type") == "Wi-Fi AP":
             ap_ssid = ap.get("kismet.device.base.commonname", "")
             if ap_ssid.strip().lower() == ssid_filter.strip().lower():
                  bssid = ap.get("kismet.device.base.macaddr")
                  if bssid:
                      found_aps.append(bssid.lower()) 

    if not found_aps:
        return [f"‚úÖ Kh√¥ng t√¨m th·∫•y AP n√†o ƒëang ho·∫°t ƒë·ªông v·ªõi SSID: **{ssid_filter}**"]
    if len(found_aps) > 1:
        logger.warning(f"T√¨m th·∫•y nhi·ªÅu AP ({len(found_aps)}) v·ªõi SSID '{ssid_filter}'. S·ª≠ d·ª•ng BSSID ƒë·∫ßu ti√™n: {found_aps[0]}")

    target_bssid = found_aps[0] # L·∫•y BSSID ƒë·∫ßu ti√™n t√¨m ƒë∆∞·ª£c
    logger.info(f"T√¨m th·∫•y BSSID {target_bssid.upper()} cho SSID '{ssid_filter}'")

    clients_list = []
    all_dev_data, dev_error = fetch_kismet_data("/devices/by-mac/*/device.json")
    if dev_error:
         # Th·ª≠ endpoint kh√°c n·∫øu endpoint tr√™n kh√¥ng ho·∫°t ƒë·ªông
         logger.warning("Kh√¥ng th·ªÉ d√πng /devices/by-mac/*/device.json, th·ª≠ /devices/views/phy-IEEE802.11/devices.json")
         all_dev_data, dev_error = fetch_kismet_data("/devices/views/phy-IEEE802.11/devices.json")
         if dev_error:
              return [f"‚ùå L·ªói khi l·∫•y danh s√°ch thi·∫øt b·ªã: {dev_error}"]

    if not all_dev_data or not isinstance(all_dev_data, list): 
        return ["‚ÑπÔ∏è Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu thi·∫øt b·ªã h·ª£p l·ªá t·ª´ Kismet."]

    for device in all_dev_data:
        if device.get("kismet.device.base.type") == "Wi-Fi Client":
            last_bssid = (device.get("dot11.device", {}).get("dot11.device.last_bssid") or
                          device.get("kismet.wireless.client. BSSID")) # Th√™m tr∆∞·ªùng d·ª± ph√≤ng n·∫øu c·∫ßn

            if last_bssid and last_bssid.lower() == target_bssid:
                mac_address = device.get("kismet.device.base.macaddr", "Unknown MAC")
                signal_info = device.get("kismet.common.signal", {})
                signal_dbm = signal_info.get("last_signal_dbm", "N/A")
                clients_list.append(f"üì± **MAC:** `{mac_address.upper()}` | **T√≠n hi·ªáu:** `{signal_dbm} dBm`")

    logger.info(f"T√¨m th·∫•y {len(clients_list)} client cho BSSID {target_bssid.upper()}")
    if not clients_list:
         return [f"‚úÖ Kh√¥ng t√¨m th·∫•y client n√†o ƒëang k·∫øt n·ªëi v√†o AP **{ssid_filter}** (BSSID: `{target_bssid.upper()}`)"]
    else:
        return [f"üë• Client ƒëang k·∫øt n·ªëi v√†o **{ssid_filter}** (BSSID: `{target_bssid.upper()}`):"] + clients_list


async def get_summary_data():
    """L·∫•y d·ªØ li·ªáu t√≥m t·∫Øt t·ª´ Kismet (APs, Clients, Alerts)."""
    summary = {
        "ap_count": 0,
        "client_count": 0,
        "new_alert_count": 0,
        "strongest_ap": None,
        "max_ap_signal": -1000,
        "strongest_client": None,
        "max_client_signal": -1000,
        "errors": []
    }
    start_time = time.time()
    logger.info("B·∫Øt ƒë·∫ßu l·∫•y d·ªØ li·ªáu t√≥m t·∫Øt...")

    ap_data, ap_error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if ap_error:
        summary["errors"].append(f"L·ªói l·∫•y AP: {ap_error}")
    elif ap_data and isinstance(ap_data, list):
        for ap in ap_data:
            if ap.get("kismet.device.base.type") == "Wi-Fi AP":
                summary["ap_count"] += 1
                try:
                    signal_dbm = ap.get("kismet.common.signal", {}).get("last_signal_dbm")
                    # Ch·ªâ c·∫≠p nh·∫≠t strongest_ap n·∫øu t√≠n hi·ªáu h·ª£p l·ªá v√† m·∫°nh h∆°n
                    if signal_dbm is not None and isinstance(signal_dbm, (int, float)) and signal_dbm > summary["max_ap_signal"]:
                        summary["max_ap_signal"] = signal_dbm
                        summary["strongest_ap"] = {
                            "ssid": ap.get("kismet.device.base.commonname", "N/A"),
                            "bssid": ap.get("kismet.device.base.macaddr", "N/A")
                        }
                except Exception as e:
                    logger.warning(f"Summary: Kh√¥ng th·ªÉ x·ª≠ l√Ω t√≠n hi·ªáu AP {ap.get('kismet.device.base.macaddr')}: {e}")
    else:
         logger.warning("Summary: D·ªØ li·ªáu AP kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng.")


    client_data, client_error = fetch_kismet_data("/devices/views/phy-IEEE802.11/devices.json") 
    if client_error:
        summary["errors"].append(f"L·ªói l·∫•y Client: {client_error}")
    elif client_data and isinstance(client_data, list):
         for device in client_data:
             if device.get("kismet.device.base.type") == "Wi-Fi Client":
                summary["client_count"] += 1
                try:
                    signal_dbm = device.get("kismet.common.signal", {}).get("last_signal_dbm")
                    if signal_dbm is not None and isinstance(signal_dbm, (int, float)) and signal_dbm > summary["max_client_signal"]:
                        summary["max_client_signal"] = signal_dbm
                        summary["strongest_client"] = {
                            "mac": device.get("kismet.device.base.macaddr", "N/A")
                        }
                except Exception as e:
                     logger.warning(f"Summary: Kh√¥ng th·ªÉ x·ª≠ l√Ω t√≠n hi·ªáu Client {device.get('kismet.device.base.macaddr')}: {e}")
    else:
        logger.warning("Summary: D·ªØ li·ªáu client kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng.")


    alert_data, alert_error = fetch_kismet_data("/alerts/all_alerts.json")
    if alert_error:
        summary["errors"].append(f"L·ªói l·∫•y C·∫£nh b√°o: {alert_error}")
    elif alert_data and isinstance(alert_data, list):
        cutoff_timestamp = (datetime.now() - timedelta(hours=24)).timestamp()

        for alert in alert_data:
            try:
                 alert_timestamp = alert.get('kismet.alert.timestamp') or alert.get('kismet.alert.sec')
                 if alert_timestamp and isinstance(alert_timestamp, (int, float)):
                     if alert_timestamp >= cutoff_timestamp:
                         summary["new_alert_count"] += 1
            except Exception as e:
                 logger.warning(f"Summary: Kh√¥ng th·ªÉ x·ª≠ l√Ω timestamp c·∫£nh b√°o {alert.get('alert_key', 'N/A')}: {e}")
    else:
        logger.warning("Summary: D·ªØ li·ªáu c·∫£nh b√°o kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng.")

    end_time = time.time()
    logger.info(f"Ho√†n th√†nh l·∫•y d·ªØ li·ªáu t√≥m t·∫Øt trong {end_time - start_time:.2f} gi√¢y.")
    return summary


# --- Telegram Command Handlers ---

async def start(update: Update, context: CallbackContext):
    """X·ª≠ l√Ω l·ªánh /start."""
    user_name = update.effective_user.first_name
    keyboard = [
        [KeyboardButton("/ap"), KeyboardButton("/summary")],
        [KeyboardButton("/alert"), KeyboardButton("/monitor")],
        [KeyboardButton("/appdf"), KeyboardButton("/help")],
        [KeyboardButton("T√¨m Client (nh·∫≠p /client SSID)")]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
    await update.message.reply_text(
        f"üëã Xin ch√†o {user_name}!\n"
        "T√¥i l√† Bot Kismet. S·ª≠ d·ª•ng c√°c n√∫t b√™n d∆∞·ªõi ho·∫∑c g√µ l·ªánh.\n"
        "G√µ /help ƒë·ªÉ xem m√¥ t·∫£ chi ti·∫øt c√°c l·ªánh.",
        reply_markup=reply_markup
    )

async def help_command(update: Update, context: CallbackContext):
    """Hi·ªÉn th·ªã danh s√°ch c√°c l·ªánh."""
    help_text = (
        "üìå **Danh s√°ch l·ªánh c√≥ s·∫µn:**\n\n"
        "`/start` - Hi·ªÉn th·ªã tin nh·∫Øn ch√†o m·ª´ng v√† b√†n ph√≠m l·ªánh.\n\n"
        "`/help` - Hi·ªÉn th·ªã danh s√°ch l·ªánh n√†y.\n\n"
        "`/ap` - üì° L·∫•y danh s√°ch Access Point (APs) ph√°t hi·ªán ƒë∆∞·ª£c t·ª´ Kismet (bao g·ªìm SSID, BSSID, B·∫£o m·∫≠t, K√™nh, T√≠n hi·ªáu).\n\n"
        "`/summary` - üìä Xem b√°o c√°o t√≥m t·∫Øt nhanh v·ªÅ Kismet (s·ªë l∆∞·ª£ng APs, Clients, c·∫£nh b√°o m·ªõi, thi·∫øt b·ªã m·∫°nh nh·∫•t).\n\n"
        "`/alert` - üîî Xem 5 c·∫£nh b√°o Kismet g·∫ßn nh·∫•t.\n\n"
        "`/client <SSID>` - üë• Li·ªát k√™ c√°c client ƒëang k·∫øt n·ªëi v√†o m·ªôt AP c√≥ SSID c·ª• th·ªÉ (v√≠ d·ª•: `/client MyWifi`).\n\n"
        "`/monitor` - üö® Ki·ªÉm tra v√† b√°o c√°o n·∫øu c√≥ AP n√†o ƒë√£ bi·∫øt (theo BSSID) thay ƒë·ªïi SSID.\n\n"
        "`/appdf` - üìÑ Xu·∫•t danh s√°ch Access Point hi·ªán t·∫°i th√†nh file PDF (y√™u c·∫ßu font ch·ªØ ƒë∆∞·ª£c c√†i ƒë·∫∑t ƒë√∫ng).\n"
        "\n_L∆∞u √Ω: M·ªôt s·ªë l·ªánh c√≥ th·ªÉ m·∫•t v√†i gi√¢y ƒë·ªÉ x·ª≠ l√Ω._"
    )
    await update.message.reply_text(help_text, parse_mode="Markdown", reply_markup=None)


async def ap_command(update: Update, context: CallbackContext):
    """L·∫•y v√† g·ª≠i danh s√°ch APs."""
    await update.message.reply_text("üì° ƒêang l·∫•y danh s√°ch Access Points t·ª´ Kismet...")
    result = await get_all_ap() 
    if result and isinstance(result, list) and result[0].startswith("‚ùå"):
         await update.message.reply_text(result[0])
    elif not result:
         await update.message.reply_text("‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y AP n√†o ho·∫∑c kh√¥ng c√≥ d·ªØ li·ªáu.")
    else:
        result_text = "\n\n".join(result)
        if not result_text.strip(): 
            await update.message.reply_text("‚úÖ Kh√¥ng t√¨m th·∫•y AP n√†o!")
        else:
            for part in split_message(result_text):
                await update.message.reply_text(part, parse_mode="Markdown")

async def appdf_command(update: Update, context: CallbackContext):
    """Xu·∫•t danh s√°ch APs th√†nh file PDF."""
    if not FONT_REGISTERED:
        await update.message.reply_text("‚ùå L·ªói: Kh√¥ng th·ªÉ t·∫°o PDF do font ch·ªØ ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω ho·∫∑c kh√¥ng t√¨m th·∫•y. Vui l√≤ng ki·ªÉm tra c·∫•u h√¨nh `FONT_PATH` trong code v√† c√†i ƒë·∫∑t font ch·ªØ.")
        return

    await update.message.reply_text("üìÑ ƒêang t·∫°o file PDF danh s√°ch Access Points...")

    ap_list_formatted = await get_all_ap() 

    if not ap_list_formatted or (isinstance(ap_list_formatted, list) and ap_list_formatted[0].startswith("‚ùå")):
        error_msg = ap_list_formatted[0] if ap_list_formatted else "‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu AP ƒë·ªÉ xu·∫•t PDF."
        await update.message.reply_text(error_msg)
        return

    pdf_filename = f"kismet_aps_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"

    try:
        c = canvas.Canvas(pdf_filename, pagesize=letter)
        width, height = letter
        margin = 0.75 * inch
        text_width = width - 2 * margin
        current_y = height - margin

        # --- Header ---
        c.setFont(FONT_NAME, 18)
        c.drawCentredString(width / 2, current_y, "B√°o c√°o Access Points - Kismet")
        current_y -= 30
        c.setFont(FONT_NAME, 10)
        c.drawString(margin, current_y, f"Ng√†y t·∫°o: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        current_y -= 25
        c.line(margin, current_y, width - margin, current_y) 
        current_y -= 20

        # --- Content ---
        textobject = c.beginText(margin, current_y)
        textobject.setFont(FONT_NAME, 9) # Gi·∫£m c·ª° ch·ªØ cho n·ªôi dung
        line_height = 12 # Chi·ªÅu cao m·ªói d√≤ng text

        for ap_entry in ap_list_formatted:
            lines = ap_entry.strip().split('\n')
            entry_height_estimate = len(lines) * line_height + 10 # ∆Ø·ªõc t√≠nh chi·ªÅu cao c·ªßa entry + kho·∫£ng c√°ch

            # Ki·ªÉm tra sang trang
            if textobject.getY() - entry_height_estimate < margin:
                c.drawText(textobject) # V·∫Ω text hi·ªán t·∫°i tr∆∞·ªõc khi sang trang
                c.showPage() # T·∫°o trang m·ªõi
                # V·∫Ω l·∫°i header trang m·ªõi (t√πy ch·ªçn)
                c.setFont(FONT_NAME, 10)
                c.drawString(margin, height - margin + 10, f"Ng√†y t·∫°o: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} (ti·∫øp theo)")
                c.line(margin, height-margin, width - margin, height-margin)
                current_y = height - margin - 20
                textobject = c.beginText(margin, current_y) # B·∫Øt ƒë·∫ßu text object m·ªõi
                textobject.setFont(FONT_NAME, 9)

            # V·∫Ω t·ª´ng d√≤ng c·ªßa entry
            for line in lines:
                 # X·ª≠ l√Ω icon (ƒë∆°n gi·∫£n h√≥a, kh√¥ng d√πng icon ph·ª©c t·∫°p trong PDF tr·ª´ khi nh√∫ng ·∫£nh)
                 clean_line = line.replace("üì° **", "SSID: ").replace("üîç **", "BSSID: ").replace("üîí **", "B·∫£o m·∫≠t: ").replace("üì∂ **", "K√™nh/T√≠n hi·ªáu:")
                 clean_line = clean_line.replace("`", "").replace("**", "") # X√≥a markdown
                 if "„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è" in clean_line or "----" in clean_line:
                     textobject.moveCursor(0, 5) # Th√™m kho·∫£ng tr·ªëng tr∆∞·ªõc d·∫•u ph√¢n c√°ch
                     textobject.textLine("-" * 70) # V·∫Ω ƒë∆∞·ªùng k·∫ª ngang ng·∫Øn
                     textobject.moveCursor(0, 5) # Th√™m kho·∫£ng tr·ªëng sau d·∫•u ph√¢n c√°ch
                 else:
                     textobject.textLine(clean_line)

            # Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t current_y th·ªß c√¥ng, textobject.getY() s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t


        c.drawText(textobject) # V·∫Ω ph·∫ßn text c√≤n l·∫°i
        c.save() # L∆∞u file PDF

        # G·ª≠i file PDF l√™n Telegram
        try:
            with open(pdf_filename, "rb") as pdf_file:
                await update.message.reply_document(
                    document=InputFile(pdf_file, filename=pdf_filename),
                    caption=f"Danh s√°ch Access Points ƒë∆∞·ª£c t·∫°o v√†o l√∫c {datetime.now().strftime('%H:%M:%S %d/%m/%Y')}"
                )
            logger.info(f"ƒê√£ g·ª≠i th√†nh c√¥ng file PDF: {pdf_filename}")
        except Exception as send_err:
             logger.error(f"L·ªói khi g·ª≠i file PDF {pdf_filename}: {send_err}")
             await update.message.reply_text(f"‚ùå ƒê√£ t·∫°o PDF nh∆∞ng l·ªói khi g·ª≠i: {send_err}")

    except Exception as e:
        logger.error(f"L·ªói nghi√™m tr·ªçng khi t·∫°o PDF: {e}", exc_info=True) # Log traceback
        await update.message.reply_text(f"‚ùå L·ªói kh√¥ng mong mu·ªën khi t·∫°o PDF: {e}")

    finally:
        # X√≥a file PDF sau khi g·ª≠i (ho·∫∑c n·∫øu c√≥ l·ªói)
        if os.path.exists(pdf_filename):
            try:
                os.remove(pdf_filename)
                logger.info(f"ƒê√£ x√≥a file t·∫°m: {pdf_filename}")
            except OSError as e:
                logger.error(f"Kh√¥ng th·ªÉ x√≥a file t·∫°m {pdf_filename}: {e}")

async def alert_command(update: Update, context: CallbackContext):
    """L·∫•y v√† g·ª≠i danh s√°ch c·∫£nh b√°o."""
    await update.message.reply_text("üîî ƒêang ki·ªÉm tra danh s√°ch c·∫£nh b√°o Kismet...")
    result = await get_alerts(limit=5) # L·∫•y 5 c·∫£nh b√°o g·∫ßn nh·∫•t
    if result and isinstance(result, list) and result[0].startswith("‚ùå"):
        await update.message.reply_text(result[0])
    elif not result:
         await update.message.reply_text("‚ÑπÔ∏è Kh√¥ng c√≥ c·∫£nh b√°o n√†o.")
    else:
        result_text = "\n\n".join(result)
        if not result_text.strip():
            await update.message.reply_text("‚úÖ Kh√¥ng c√≥ c·∫£nh b√°o n√†o trong 5 c·∫£nh b√°o g·∫ßn nh·∫•t.")
        else:
            for part in split_message(result_text):
                await update.message.reply_text(part, parse_mode="Markdown")


async def client_command(update: Update, context: CallbackContext):
    """L·∫•y danh s√°ch client k·∫øt n·ªëi v√†o m·ªôt SSID."""
    if not context.args:
        await update.message.reply_text(
            "‚ö†Ô∏è Vui l√≤ng nh·∫≠p **SSID** c·ªßa AP!\n"
            "V√≠ d·ª•: `/client Tenda_123` ho·∫∑c `/client \"My Wifi Network\"` (d√πng ngo·∫∑c k√©p n·∫øu SSID c√≥ kho·∫£ng tr·∫Øng).",
            parse_mode="Markdown"
        )
        return

    ssid_filter = " ".join(context.args).strip()
    await update.message.reply_text(f"üë• ƒêang t√¨m client k·∫øt n·ªëi v√†o AP c√≥ SSID: **{ssid_filter}**...", parse_mode="Markdown")

    result = await get_clients_by_ap(ssid_filter) # result l√† list string

    if result and isinstance(result, list) and result[0].startswith("‚ùå"):
        await update.message.reply_text(result[0], parse_mode="Markdown")
    elif not result:
         await update.message.reply_text(f"‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y th√¥ng tin client cho SSID: **{ssid_filter}**.", parse_mode="Markdown")
    else:
        result_text = "\n".join(result) # N·ªëi b·∫±ng \n thay v√¨ \n\n
        for part in split_message(result_text):
            await update.message.reply_text(part, parse_mode="Markdown")


async def monitor_command(update: Update, context: CallbackContext):
    """Ki·ªÉm tra s·ª± thay ƒë·ªïi SSID v√† b√°o c√°o RAP."""
    await update.message.reply_text("üö® ƒêang ki·ªÉm tra thay ƒë·ªïi SSID (RAP Detection)...")
    rogue_aps = await monitor_ssid_changes() # Tr·∫£ v·ªÅ list c√°c string ho·∫∑c list l·ªói

    if not rogue_aps:
        await update.message.reply_text("‚úÖ Kh√¥ng ph√°t hi·ªán BSSID n√†o thay ƒë·ªïi SSID b·∫•t th∆∞·ªùng.")
    elif isinstance(rogue_aps, list) and rogue_aps[0].startswith("‚ùå"):
         await update.message.reply_text(f"L·ªói khi gi√°m s√°t: {rogue_aps[0]}")
    else:
        response = "‚ö†Ô∏è **C·∫£nh b√°o thay ƒë·ªïi SSID:**\n\n" + "\n\n".join(rogue_aps)
        for part in split_message(response):
            await update.message.reply_text(part, parse_mode="Markdown")

async def summary_command(update: Update, context: CallbackContext):
    """L·∫•y v√† hi·ªÉn th·ªã b√°o c√°o t√≥m t·∫Øt Kismet."""
    await update.message.reply_text("üìä ƒêang t·∫°o b√°o c√°o t√≥m t·∫Øt Kismet...")

    summary_data = await get_summary_data()

    # --- X·ª≠ l√Ω l·ªói n·∫øu c√≥ ---
    if summary_data["errors"]:
        error_message = "‚ö†Ô∏è ƒê√£ x·∫£y ra l·ªói khi l·∫•y d·ªØ li·ªáu t√≥m t·∫Øt:\n- " + "\n- ".join(summary_data["errors"])
        # V·∫´n ti·∫øp t·ª•c hi·ªÉn th·ªã ph·∫ßn d·ªØ li·ªáu l·∫•y ƒë∆∞·ª£c n·∫øu c√≥
        await update.message.reply_text(error_message)

    # --- Format Tin nh·∫Øn K·∫øt qu·∫£ ---
    summary_text = "üìä **B√°o c√°o T√≥m t·∫Øt Kismet** üìä\n"
    summary_text += "------------------------------------\n"
    summary_text += f"üì° **T·ªïng s·ªë Access Points:** `{summary_data['ap_count']}`\n"
    summary_text += f"üì± **T·ªïng s·ªë Clients Wi-Fi:** `{summary_data['client_count']}`\n"
    summary_text += f"üîî **C·∫£nh b√°o m·ªõi (24h):** `{summary_data['new_alert_count']}`\n"
    summary_text += "------------------------------------\n\n"

    if summary_data["strongest_ap"]:
        ap = summary_data['strongest_ap']
        signal = summary_data['max_ap_signal']
        summary_text += (f"üëë **AP T√≠n hi·ªáu M·∫°nh nh·∫•t:**\n"
                         f"   SSID: `{ap['ssid']}`\n"
                         f"   BSSID: `{ap['bssid'].upper()}`\n"
                         f"   T√≠n hi·ªáu: `{signal} dBm`\n\n")
    else:
        summary_text += "üëë **AP T√≠n hi·ªáu M·∫°nh nh·∫•t:** `(Kh√¥ng c√≥ d·ªØ li·ªáu)`\n\n"

    if summary_data["strongest_client"]:
        client = summary_data['strongest_client']
        signal = summary_data['max_client_signal']
        summary_text += (f"üí™ **Client T√≠n hi·ªáu M·∫°nh nh·∫•t:**\n"
                         f"   MAC: `{client['mac'].upper()}`\n"
                         f"   T√≠n hi·ªáu: `{signal} dBm`\n")
    else:
        summary_text += "üí™ **Client T√≠n hi·ªáu M·∫°nh nh·∫•t:** `(Kh√¥ng c√≥ d·ªØ li·ªáu)`\n"

    # --- G·ª≠i Tin nh·∫Øn ---
    # G·ª≠i kh√¥ng c√≥ b√†n ph√≠m reply cho l·ªánh n√†y
    await update.message.reply_text(summary_text, parse_mode="Markdown", reply_markup=None)


# --- Error Handler ---

async def error_handler(update: object, context: CallbackContext):
    """Log l·ªói v√† th√¥ng b√°o cho ng∆∞·ªùi d√πng."""
    logger.error(f"Exception while handling an update: {context.error}", exc_info=context.error)

    # C·ªë g·∫Øng th√¥ng b√°o l·ªói cho ng∆∞·ªùi d√πng n·∫øu c√≥ th·ªÉ
    if isinstance(update, Update) and update.effective_message:
        try:
            await update.effective_message.reply_text("‚ùå R·∫•t ti·∫øc, ƒë√£ c√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau.")
        except Exception as e:
            logger.error(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o l·ªói cho ng∆∞·ªùi d√πng: {e}")

# --- Setup and Run ---

def setup_handlers(application):
    """ƒêƒÉng k√Ω t·∫•t c·∫£ c√°c command handler."""
    handlers = [
        CommandHandler("start", start),
        CommandHandler("help", help_command),
        CommandHandler("ap", ap_command),
        CommandHandler("summary", summary_command),
        CommandHandler("alert", alert_command),
        CommandHandler("client", client_command),
        CommandHandler("monitor", monitor_command),
        CommandHandler("appdf", appdf_command),
         # Th√™m MessageHandler ƒë·ªÉ b·∫Øt c√°c l·ªánh kh√¥ng h·ª£p l·ªá ho·∫∑c tin nh·∫Øn th∆∞·ªùng
         # Tr·∫£ v·ªÅ help n·∫øu ng∆∞·ªùi d√πng g·ª≠i tin nh·∫Øn kh√¥ng ph·∫£i l·ªánh
         MessageHandler(filters.TEXT & ~filters.COMMAND, help_command)
    ]
    for handler in handlers:
        application.add_handler(handler)

    # ƒêƒÉng k√Ω error handler
    application.add_error_handler(error_handler)
    logger.info("ƒê√£ ƒëƒÉng k√Ω c√°c handlers.")

def main():
    """Kh·ªüi ch·∫°y bot Telegram."""
    logger.info("B·∫Øt ƒë·∫ßu kh·ªüi t·∫°o bot...")
    try:
        application = Application.builder().token(TOKEN).build()
        setup_handlers(application)
        logger.info("Bot ƒëang b·∫Øt ƒë·∫ßu ch·∫°y...")
        application.run_polling()
    except Exception as e:
        logger.critical(f"L·ªói nghi√™m tr·ªçng khi kh·ªüi t·∫°o ho·∫∑c ch·∫°y bot: {e}", exc_info=True)

if __name__ == "__main__":
    main()
